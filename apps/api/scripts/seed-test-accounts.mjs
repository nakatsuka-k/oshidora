#!/usr/bin/env node

// Generates idempotent UPSERT SQL for test accounts in production D1.
// Hashing matches apps/api/src/index.ts: PBKDF2(SHA-256), salt 16 bytes, hash 32 bytes, iterations 100_000.
//
// Usage:
//   node ./scripts/seed-test-accounts.mjs \
//     --cmsEmail "cms-test-admin+20260113@oshidra.com" --cmsName "Test Admin" --cmsPassword "..." \
//     --userEmail "app-test-user+20260113@oshidra.com" --userPassword "..." \
//     > /tmp/oshidora-seed-test-accounts.sql
//
// Then:
//   npx -y wrangler d1 execute oshidora-db --remote --file /tmp/oshidora-seed-test-accounts.sql

import crypto from 'node:crypto'

function usage() {
  console.log(`Usage:
  node ./scripts/seed-test-accounts.mjs \\
    --cmsEmail you@example.com --cmsName "Admin" --cmsPassword "..." \\
    --userEmail user@example.com --userPassword "..." \\
    [--cmsId cms_...] [--cmsRole Admin] [--userId user_...] [--userEmailVerified 1]

Outputs SQL (UPSERT) to stdout.
`)
}

function getArg(flag) {
  const idx = process.argv.indexOf(flag)
  if (idx === -1) return ''
  return String(process.argv[idx + 1] ?? '').trim()
}

function parseBool01(value, defaultValue = 0) {
  const s = String(value ?? '').trim().toLowerCase()
  if (!s) return defaultValue
  if (s === '1' || s === 'true' || s === 'yes' || s === 'on') return 1
  if (s === '0' || s === 'false' || s === 'no' || s === 'off') return 0
  return defaultValue
}

function base64Encode(u8) {
  return Buffer.from(u8).toString('base64')
}

async function pbkdf2HashPassword(password, saltBytes, iterations = 100_000) {
  const keyMaterial = await crypto.webcrypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(password),
    { name: 'PBKDF2' },
    false,
    ['deriveBits']
  )
  const bits = await crypto.webcrypto.subtle.deriveBits(
    { name: 'PBKDF2', hash: 'SHA-256', salt: saltBytes, iterations },
    keyMaterial,
    32 * 8
  )
  return new Uint8Array(bits)
}

async function hashPasswordForStorage(password) {
  const salt = crypto.webcrypto.getRandomValues(new Uint8Array(16))
  const hash = await pbkdf2HashPassword(password, salt)
  return { saltB64: base64Encode(salt), hashB64: base64Encode(hash) }
}

function escapeSqlString(value) {
  return String(value).replace(/'/g, "''")
}

function q(value) {
  return `'${escapeSqlString(value)}'`
}

async function main() {
  const cmsEmail = getArg('--cmsEmail').toLowerCase()
  const cmsName = getArg('--cmsName')
  const cmsPassword = getArg('--cmsPassword')
  const cmsId = getArg('--cmsId') || crypto.randomUUID()
  const cmsRole = getArg('--cmsRole') || 'Admin'

  const userEmail = getArg('--userEmail').toLowerCase()
  const userPassword = getArg('--userPassword')
  const userId = getArg('--userId') || crypto.randomUUID()
  const userEmailVerified = parseBool01(getArg('--userEmailVerified'), 1)

  if (!cmsEmail || !cmsName || !cmsPassword || !userEmail || !userPassword) {
    usage()
    process.exitCode = 1
    return
  }

  const now = new Date().toISOString()

  const cms = await hashPasswordForStorage(cmsPassword)
  const user = await hashPasswordForStorage(userPassword)

  const sqlLines = []
  sqlLines.push('-- Generated by apps/api/scripts/seed-test-accounts.mjs')
  sqlLines.push(`-- Generated at: ${now}`)

  // cms_admins UPSERT by email
  sqlLines.push(
    [
      'INSERT INTO cms_admins (id, email, name, role, password_hash, password_salt, disabled, created_at, updated_at)',
      'VALUES (' +
        [
          q(cmsId),
          q(cmsEmail),
          q(cmsName),
          q(cmsRole),
          q(cms.hashB64),
          q(cms.saltB64),
          '0',
          q(now),
          q(now),
        ].join(', ') +
        ')',
      'ON CONFLICT(email) DO UPDATE SET',
      '  name = excluded.name,',
      '  role = excluded.role,',
      '  password_hash = excluded.password_hash,',
      '  password_salt = excluded.password_salt,',
      '  disabled = 0,',
      '  updated_at = excluded.updated_at;',
    ].join('\n')
  )

  // users UPSERT by email
  sqlLines.push(
    [
      'INSERT INTO users (id, email, email_verified, phone, phone_verified, password_hash, password_salt, created_at, updated_at)',
      'VALUES (' +
        [
          q(userId),
          q(userEmail),
          String(userEmailVerified),
          'NULL',
          '0',
          q(user.hashB64),
          q(user.saltB64),
          q(now),
          q(now),
        ].join(', ') +
        ')',
      'ON CONFLICT(email) DO UPDATE SET',
      '  email_verified = excluded.email_verified,',
      '  password_hash = excluded.password_hash,',
      '  password_salt = excluded.password_salt,',
      '  updated_at = excluded.updated_at;',
    ].join('\n')
  )

  process.stdout.write(sqlLines.join('\n\n') + '\n')
}

main().catch((e) => {
  console.error(e)
  process.exitCode = 1
})
