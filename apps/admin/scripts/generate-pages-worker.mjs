import fs from 'node:fs'
import path from 'node:path'

const repoRoot = process.cwd()

const distDir = path.join(repoRoot, 'dist')
const outFile = path.join(distDir, '_worker.js')

const ROBOTS_TAG = 'noindex, nofollow, noarchive'

function parseAllowedIpsFromEnv() {
  const raw = String(process.env.OSHIDORA_ALLOWED_IPS || '').trim()
  if (!raw) return null
  return raw
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean)
}

// Keep in sync with apps/mobile/scripts/generate-pages-worker.mjs
const DEFAULT_ALLOWED_IPS = [
  '223.135.200.51',
  '117.102.205.215',
  '133.232.96.225',
  '3.114.72.126',
  '133.200.10.97',
  '159.28.175.137',
  '2400:2412:2e2:a800:a121:14c:42fa:4ce2',
]

function uniq(list) {
  return Array.from(new Set(list)).filter(Boolean)
}

function main() {
  if (!fs.existsSync(distDir)) {
    console.error(`[generate-pages-worker][admin] dist directory not found: ${distDir}`)
    process.exit(1)
  }

  const envIps = parseAllowedIpsFromEnv()
  // Admin IP restriction is disabled by default (public access).
  // If you want to enable an allowlist, set OSHIDORA_ALLOWED_IPS (comma-separated).
  // When enabled, keep DEFAULT_ALLOWED_IPS active (and allow env additions).
  const allowedIps = envIps ? uniq([...DEFAULT_ALLOWED_IPS, ...envIps]) : []

  const source = `// Auto-generated by apps/admin/scripts/generate-pages-worker.mjs
// Cloudflare Pages Worker: IP allowlist + noindex

const ALLOWED_IPS = ${JSON.stringify(allowedIps)};
const ROBOTS_TAG = ${JSON.stringify(ROBOTS_TAG)};

function splitXForwardedFor(xff) {
  if (!xff) return [];
  return String(xff)
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
}

function getClientIps(request) {
  const cf = request.headers.get('CF-Connecting-IP') || '';
  const xff = request.headers.get('X-Forwarded-For') || '';
  const ips = [];
  if (cf) ips.push(cf);
  ips.push(...splitXForwardedFor(xff));
  return {
    cf,
    xff,
    ips: Array.from(new Set(ips)).filter(Boolean),
  };
}

function isIPAllowed(ips) {
  // If allowlist is empty, allow all.
  if (!ALLOWED_IPS || ALLOWED_IPS.length === 0) return true;
  return ips.some((clientIP) => ALLOWED_IPS.some((allowed) => clientIP === allowed));
}

function getDeniedHTML(details) {
  return (
    '<!DOCTYPE html>' +
    '<html>' +
    '<head>' +
    '  <meta charset="UTF-8">' +
    '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
    '  <meta name="robots" content="noindex,nofollow,noarchive">' +
    '  <title>Access Denied</title>' +
    '</head>' +
    '<body style="font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; padding: 24px;">' +
    '  <h1 style="margin: 0 0 12px 0; color: #b00020;">Access Denied</h1>' +
    '  <p style="margin: 0 0 12px 0;">Your IP address is not authorized to access this site.</p>' +
    '  <div style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background: #f6f6f6; padding: 12px; border-radius: 8px;">' +
    '    CF-Connecting-IP: ' + (details.cf || '(none)') + '<br>' +
    '    X-Forwarded-For: ' + (details.xff || '(none)') + '<br>' +
    '    Parsed IPs: ' + (details.ips && details.ips.length ? details.ips.join(', ') : '(none)') +
    '  </div>' +
    '  <p style="margin: 12px 0 0 0; color: #666; font-size: 13px;">Whitelist the public IP shown above (CF-Connecting-IP).</p>' +
    '</body>' +
    '</html>'
  );
}

export default {
  async fetch(request, env) {
    const details = getClientIps(request);

    if (!isIPAllowed(details.ips)) {
      return new Response(getDeniedHTML(details), {
        status: 403,
        headers: {
          'Content-Type': 'text/html; charset=utf-8',
          'X-Robots-Tag': ROBOTS_TAG,
        },
      });
    }

    const res = await env.ASSETS.fetch(request);

    // SPA fallback: serve /index.html for non-asset HTML routes.
    // This prevents deep-link navigation (e.g. /unapproved-videos) from returning not_found.
    const accept = request.headers.get('Accept') || '';
    const url = new URL(request.url);
    const isGet = request.method === 'GET';
    const isHtml = accept.includes('text/html');
    const looksLikeAsset = /\.[a-zA-Z0-9]+$/.test(url.pathname);
    if (res.status === 404 && isGet && isHtml && !looksLikeAsset) {
      const indexUrl = new URL(request.url);
      indexUrl.pathname = '/index.html';
      const indexRes = await env.ASSETS.fetch(new Request(indexUrl.toString(), request));
      const headers = new Headers(indexRes.headers);
      headers.set('X-Robots-Tag', ROBOTS_TAG);
      return new Response(indexRes.body, {
        status: indexRes.status,
        statusText: indexRes.statusText,
        headers,
      });
    }

    const headers = new Headers(res.headers);
    headers.set('X-Robots-Tag', ROBOTS_TAG);
    return new Response(res.body, {
      status: res.status,
      statusText: res.statusText,
      headers,
    });
  },
};
`

  fs.writeFileSync(outFile, source, 'utf8')
  console.log(`[generate-pages-worker][admin] wrote ${path.relative(repoRoot, outFile)}`)
  if (allowedIps.length > 0) {
    console.log(`[generate-pages-worker][admin] IP allowlist enabled: ${allowedIps.length}`)
  } else {
    console.log('[generate-pages-worker][admin] IP allowlist disabled (public access)')
  }
}

main()
