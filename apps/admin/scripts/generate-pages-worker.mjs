import fs from 'node:fs'
import path from 'node:path'

const repoRoot = process.cwd()

const distDir = path.join(repoRoot, 'dist')
const outFile = path.join(distDir, '_worker.js')

const ROBOTS_TAG = 'noindex, nofollow, noarchive'

function parseAllowedIpsFromEnv() {
  const raw = String(process.env.OSHIDORA_ALLOWED_IPS || '').trim()
  if (!raw) return []
  return raw
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean)
}

// Keep in sync with apps/mobile/scripts/generate-pages-worker.mjs
const DEFAULT_ALLOWED_IPS = [
  '223.135.200.51',
  '117.102.205.215',
  '133.232.96.225',
  '3.114.72.126',
  '133.200.10.97',
  '159.28.175.137',
]

function uniq(list) {
  return Array.from(new Set(list)).filter(Boolean)
}

function main() {
  if (!fs.existsSync(distDir)) {
    console.error(`[generate-pages-worker][admin] dist directory not found: ${distDir}`)
    process.exit(1)
  }

  const envIps = parseAllowedIpsFromEnv()
  // Admin must always be IP-restricted. If OSHIDORA_ALLOWED_IPS is not set,
  // fall back to DEFAULT_ALLOWED_IPS (same as mobile allowlist default).
  const allowedIps = uniq([...DEFAULT_ALLOWED_IPS, ...envIps])

  const source = `// Auto-generated by apps/admin/scripts/generate-pages-worker.mjs
// Cloudflare Pages Worker: IP allowlist + noindex

const ALLOWED_IPS = ${JSON.stringify(allowedIps)};
const ROBOTS_TAG = ${JSON.stringify(ROBOTS_TAG)};

function splitXForwardedFor(xff) {
  if (!xff) return [];
  return String(xff)
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
}

function getClientIps(request) {
  const cf = request.headers.get('CF-Connecting-IP') || '';
  const xff = request.headers.get('X-Forwarded-For') || '';
  const ips = [];
  if (cf) ips.push(cf);
  ips.push(...splitXForwardedFor(xff));
  return {
    cf,
    xff,
    ips: Array.from(new Set(ips)).filter(Boolean),
  };
}

function isIPAllowed(ips) {
  if (!ALLOWED_IPS || ALLOWED_IPS.length === 0) return false;
  return ips.some((clientIP) => ALLOWED_IPS.some((allowed) => clientIP === allowed));
}

function getDeniedHTML(details) {
  return (
    '<!DOCTYPE html>' +
    '<html>' +
    '<head>' +
    '  <meta charset="UTF-8">' +
    '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
    '  <meta name="robots" content="noindex,nofollow,noarchive">' +
    '  <title>Access Denied</title>' +
    '</head>' +
    '<body style="font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; padding: 24px;">' +
    '  <h1 style="margin: 0 0 12px 0; color: #b00020;">Access Denied</h1>' +
    '  <p style="margin: 0 0 12px 0;">Your IP address is not authorized to access this site.</p>' +
    '  <div style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background: #f6f6f6; padding: 12px; border-radius: 8px;">' +
    '    CF-Connecting-IP: ' + (details.cf || '(none)') + '<br>' +
    '    X-Forwarded-For: ' + (details.xff || '(none)') + '<br>' +
    '    Parsed IPs: ' + (details.ips && details.ips.length ? details.ips.join(', ') : '(none)') +
    '  </div>' +
    '  <p style="margin: 12px 0 0 0; color: #666; font-size: 13px;">Whitelist the public IP shown above (CF-Connecting-IP).</p>' +
    '</body>' +
    '</html>'
  );
}

export default {
  async fetch(request, env) {
    const details = getClientIps(request);

    if (!isIPAllowed(details.ips)) {
      return new Response(getDeniedHTML(details), {
        status: 403,
        headers: {
          'Content-Type': 'text/html; charset=utf-8',
          'X-Robots-Tag': ROBOTS_TAG,
        },
      });
    }

    const res = await env.ASSETS.fetch(request);
    const headers = new Headers(res.headers);
    headers.set('X-Robots-Tag', ROBOTS_TAG);
    return new Response(res.body, {
      status: res.status,
      statusText: res.statusText,
      headers,
    });
  },
};
`

  fs.writeFileSync(outFile, source, 'utf8')
  console.log(`[generate-pages-worker][admin] wrote ${path.relative(repoRoot, outFile)}`)
  console.log(`[generate-pages-worker][admin] allowlist size: ${allowedIps.length}`)
}

main()
