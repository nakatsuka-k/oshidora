import fs from 'node:fs';
import path from 'node:path';

const repoRoot = process.cwd();

const distDir = path.join(repoRoot, 'dist');
const outFile = path.join(distDir, '_worker.js');

const ROBOTS_TAG = 'noindex, nofollow, noarchive';

function main() {
  if (!fs.existsSync(distDir)) {
    console.error(`[generate-pages-worker] dist directory not found: ${distDir}`);
    process.exit(1);
  }

  const source = `// Auto-generated by apps/mobile/scripts/generate-pages-worker.mjs
// Pages Worker with IP allowlist protection

const ROBOTS_TAG = ${JSON.stringify(ROBOTS_TAG)};

// D1-backed allowlist: uses the shared table access_ip_allowlist.
// Bind D1 as env.DB in wrangler.toml / Pages bindings.
let allowlistCache = null;

function allowlistCacheTtlMs(env) {
  const raw = String((env && env.IP_ALLOWLIST_CACHE_TTL_SECONDS) || '').trim();
  const n = raw ? Number(raw) : 30;
  if (!Number.isFinite(n) || n < 0) return 30_000;
  return Math.min(Math.max(0, Math.floor(n * 1000)), 5 * 60_000);
}

function normalizeIp(value) {
  const s = String(value || '').trim();
  if (!s) return '';
  // IPv6 in brackets: [::1]:1234
  if (s.startsWith('[')) {
    const end = s.indexOf(']');
    if (end > 0) return s.slice(1, end).toLowerCase();
    return s.toLowerCase();
  }
  // IPv4 with port: 1.2.3.4:1234
  const m = s.match(/^(\\d+\\.\\d+\\.\\d+\\.\\d+)(?::\\d+)?$/);
  if (m) return m[1];
  return s.toLowerCase();
}

function ipv4ToU32(ip) {
  const parts = String(ip || '').split('.');
  if (parts.length !== 4) return null;
  const n = parts.map((p) => (/^\\d{1,3}$/.test(p) ? Number(p) : NaN));
  if (n.some((x) => !Number.isFinite(x) || x < 0 || x > 255)) return null;
  return (((n[0] << 24) | (n[1] << 16) | (n[2] << 8) | n[3]) >>> 0);
}

function ipv6ToBytes(ip) {
  const s = String(ip || '').trim().toLowerCase();
  if (!s) return null;
  const raw = s.startsWith('[') ? s.slice(1, s.indexOf(']') > 0 ? s.indexOf(']') : s.length) : s;
  if (!raw.includes(':')) return null;
  const parts = raw.split('::');
  if (parts.length > 2) return null;

  const left = parts[0] ? parts[0].split(':').filter(Boolean) : [];
  const right = parts.length === 2 && parts[1] ? parts[1].split(':').filter(Boolean) : [];

  const groups = [];

  function pushGroupToken(tok) {
    if (!tok) return true;
    if (tok.includes('.')) {
      const v4 = ipv4ToU32(tok);
      if (v4 == null) return false;
      groups.push((v4 >>> 16) & 0xffff);
      groups.push(v4 & 0xffff);
      return true;
    }
    if (!/^[0-9a-f]{1,4}$/.test(tok)) return false;
    groups.push(parseInt(tok, 16));
    return true;
  }

  for (const t of left) {
    if (!pushGroupToken(t)) return null;
  }

  const rightGroups = [];
  for (const t of right) {
    if (t.includes('.')) {
      const v4 = ipv4ToU32(t);
      if (v4 == null) return null;
      rightGroups.push((v4 >>> 16) & 0xffff);
      rightGroups.push(v4 & 0xffff);
      continue;
    }
    if (!/^[0-9a-f]{1,4}$/.test(t)) return null;
    rightGroups.push(parseInt(t, 16));
  }

  if (parts.length === 2) {
    const zerosNeeded = 8 - (groups.length + rightGroups.length);
    if (zerosNeeded < 0) return null;
    for (let i = 0; i < zerosNeeded; i++) groups.push(0);
    groups.push(...rightGroups);
  } else {
    groups.push(...rightGroups);
  }

  if (groups.length !== 8) return null;
  const out = new Uint8Array(16);
  for (let i = 0; i < 8; i++) {
    const g = groups[i];
    out[i * 2] = (g >>> 8) & 0xff;
    out[i * 2 + 1] = g & 0xff;
  }
  return out;
}

function matchesIpv6Cidr(clientIp, baseIp, prefix) {
  const client = ipv6ToBytes(clientIp);
  const base = ipv6ToBytes(baseIp);
  if (!client || !base) return false;
  if (!Number.isFinite(prefix) || prefix < 0 || prefix > 128) return false;
  const wholeBytes = Math.floor(prefix / 8);
  const remBits = prefix % 8;
  for (let i = 0; i < wholeBytes; i++) {
    if (client[i] !== base[i]) return false;
  }
  if (remBits === 0) return true;
  const mask = (0xff << (8 - remBits)) & 0xff;
  return (client[wholeBytes] & mask) === (base[wholeBytes] & mask);
}

function matchesRule(clientIp, ruleRaw) {
  const rule = String(ruleRaw || '').trim().toLowerCase();
  if (!rule) return false;
  if (!rule.includes('/')) return String(clientIp || '').toLowerCase() === rule;

  // IPv4 CIDR
  const m4 = rule.match(/^([0-9]{1,3}(?:\\.[0-9]{1,3}){3})\\/(\\d{1,2})$/);
  if (m4) {
    const baseIp = m4[1];
    const prefix = Number(m4[2]);
    if (!Number.isFinite(prefix) || prefix < 0 || prefix > 32) return false;
    const clientU32 = ipv4ToU32(clientIp);
    const baseU32 = ipv4ToU32(baseIp);
    if (clientU32 == null || baseU32 == null) return false;
    const mask = prefix === 0 ? 0 : ((0xffffffff << (32 - prefix)) >>> 0);
    return (clientU32 & mask) === (baseU32 & mask);
  }

  // IPv6 CIDR
  const m6 = rule.match(/^([0-9a-f:.]+)\\/(\\d{1,3})$/);
  if (m6) {
    const baseIp = m6[1];
    const prefix = Number(m6[2]);
    return matchesIpv6Cidr(clientIp, baseIp, prefix);
  }

  return false;
}

async function loadAllowlistRules(env) {
  const now = Date.now();
  if (allowlistCache && now < allowlistCache.expiresAtMs) return allowlistCache.rules;

  if (!env || !env.DB) {
    throw new Error('DB is not configured');
  }

  const out = await env.DB.prepare(
    'SELECT rule FROM access_ip_allowlist WHERE enabled = 1 ORDER BY id ASC'
  ).all();
  const rules = (out.results || [])
    .map((r) => String((r && r.rule) || '').trim().toLowerCase())
    .filter(Boolean);

  allowlistCache = { expiresAtMs: now + allowlistCacheTtlMs(env), rules };
  return rules;
}

function splitXForwardedFor(xff) {
  if (!xff) return [];
  return String(xff)
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
}

function getClientIps(request) {
  const cf = request.headers.get('CF-Connecting-IP') || '';
  const xff = request.headers.get('X-Forwarded-For') || '';
  const ips = [];
  if (cf) ips.push(normalizeIp(cf));
  ips.push(...splitXForwardedFor(xff).map(normalizeIp));
  // uniq
  return {
    cf,
    xff,
    ips: Array.from(new Set(ips)).filter(Boolean),
  };
}

async function isIPAllowed(env, ips) {
  const rules = await loadAllowlistRules(env);
  if (!rules || rules.length === 0) return false;
  return ips.some((clientIP) => rules.some((rule) => matchesRule(clientIP, rule)));
}

function getDeniedHTML(details) {
  return '<!DOCTYPE html>' +
    '<html>' +
    '<head>' +
    '  <meta charset="UTF-8">' +
    '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
    '  <meta name="robots" content="noindex,nofollow,noarchive">' +
    '  <title>Access Denied</title>' +
    '  <style>' +
    '    body {' +
    '      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;' +
    '      display: flex;' +
    '      justify-content: center;' +
    '      align-items: center;' +
    '      height: 100vh;' +
    '      margin: 0;' +
    '      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);' +
    '    }' +
    '    .container {' +
    '      text-align: center;' +
    '      background: white;' +
    '      padding: 40px;' +
    '      border-radius: 8px;' +
    '      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);' +
    '      max-width: 500px;' +
    '    }' +
    '    h1 {' +
    '      color: #d32f2f;' +
    '      margin: 0 0 16px 0;' +
    '      font-size: 28px;' +
    '    }' +
    '    p {' +
    '      color: #666;' +
    '      margin: 0;' +
    '      line-height: 1.6;' +
    '      font-size: 16px;' +
    '    }' +
    '    .error-code {' +
    '      color: #999;' +
    '      margin-top: 20px;' +
    '      font-size: 12px;' +
    '      font-family: monospace;' +
    '      background: #f5f5f5;' +
    '      padding: 10px;' +
    '      border-radius: 4px;' +
    '    }' +
    '  </style>' +
    '</head>' +
    '<body>' +
    '  <div class="container">' +
    '    <h1>â›” Access Denied</h1>' +
    '    <p>Your IP address is not authorized to access this resource.</p>' +
    '    <div class="error-code">' +
    '      Allowlist: ' + (details.allowlistStatus || '(unknown)') + '<br>' +
    '      CF-Connecting-IP: ' + (details.cf || '(none)') + '<br>' +
    '      X-Forwarded-For: ' + (details.xff || '(none)') + '<br>' +
    '      Parsed IPs: ' + (details.ips && details.ips.length ? details.ips.join(', ') : '(none)') +
    '    </div>' +
    '    <p style="margin-top:12px; font-size: 13px; color:#999;">Whitelist the public IP shown above (CF-Connecting-IP).</p>' +
    '  </div>' +
    '</body>' +
    '</html>';
}

export default {
  async fetch(request, env) {
    const details = getClientIps(request);

    let allowed = false;
    let allowlistStatus = 'd1_unknown';
    try {
      allowed = await isIPAllowed(env, details.ips);
      allowlistStatus = allowed ? 'd1_ok_allowed' : 'd1_ok_denied';
    } catch (e) {
      allowed = false;
      allowlistStatus = String((e && e.message) || e || 'd1_error').slice(0, 80);
    }

    details.allowlistStatus = allowlistStatus;

    if (!allowed) {
      return new Response(getDeniedHTML(details), {
        status: 403,
        headers: {
          'Content-Type': 'text/html; charset=utf-8',
          'X-Robots-Tag': ROBOTS_TAG,
          'X-Allowlist-Status': allowlistStatus,
        },
      });
    }

    const url = new URL(request.url);

    const isProbablyAssetPath = (pathname) => {
      // If the path contains a dot segment (e.g. /assets/app.js, /favicon.ico), treat it as a static asset.
      // We still allow "/index.html" explicitly.
      if (!pathname) return false;
      if (pathname === '/index.html') return true;
      return pathname.split('/').some((seg) => seg.includes('.') && seg !== '.' && seg !== '..');
    };

    const wantsHtml = (req) => {
      const accept = req.headers.get('Accept') || '';
      return accept.includes('text/html');
    };

    // Cloudflare Pages provides the static asset binding as env.ASSETS.
    // For SPA routing (clean URLs), serve index.html as a fallback when a route path 404s.
    let res = await env.ASSETS.fetch(request);

    if (
      res.status === 404 &&
      request.method === 'GET' &&
      !isProbablyAssetPath(url.pathname) &&
      wantsHtml(request)
    ) {
      const indexUrl = new URL('/index.html', url);
      const indexReq = new Request(indexUrl, request);
      res = await env.ASSETS.fetch(indexReq);
    }

    const headers = new Headers(res.headers);
    headers.set('X-Robots-Tag', ROBOTS_TAG);
    return new Response(res.body, {
      status: res.status,
      statusText: res.statusText,
      headers,
    });
  },
};
`;

  fs.writeFileSync(outFile, source, 'utf8');
  console.log(`[generate-pages-worker] wrote ${path.relative(repoRoot, outFile)}`);
  console.log('[generate-pages-worker] IP allowlist is D1-backed (access_ip_allowlist)');
}

main();
