import fs from 'node:fs';
import path from 'node:path';

const repoRoot = process.cwd();

const distDir = path.join(repoRoot, 'dist');
const outFile = path.join(distDir, '_worker.js');

const ROBOTS_TAG = 'noindex, nofollow, noarchive';

function parseAllowedIpsFromEnv() {
  const raw = String(process.env.OSHIDORA_ALLOWED_IPS || '').trim();
  if (!raw) return null;
  const ips = raw
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
  return ips.length ? ips : null;
}

const DEFAULT_ALLOWED_IPS = [
  '223.135.200.51',
  '117.102.205.215',
  '133.232.96.225',
  '3.114.72.126',
  '133.200.10.97',
  '159.28.175.137',
  '2400:4051:e7a0:2c00:5090:89ef:d4df:bd71',
]

function main() {
  if (!fs.existsSync(distDir)) {
    console.error(`[generate-pages-worker] dist directory not found: ${distDir}`);
    process.exit(1);
  }

  const envIps = parseAllowedIpsFromEnv();
  // Restrict access to DEFAULT_ALLOWED_IPS.
  // If OSHIDORA_ALLOWED_IPS is set, it adds additional allowed IPs (comma-separated).
  // This keeps the defaults active even when a Pages env var is configured.
  const allowedIps = Array.from(new Set([...DEFAULT_ALLOWED_IPS, ...(envIps ?? [])]));
  const ipsJson = JSON.stringify(allowedIps);
  
  const source = `// Auto-generated by apps/mobile/scripts/generate-pages-worker.mjs
// Pages Worker with IP allowlist protection

const ALLOWED_IPS = ${ipsJson};
const ROBOTS_TAG = ${JSON.stringify(ROBOTS_TAG)};

function normalizeIp(value) {
  const s = String(value || '').trim();
  if (!s) return '';
  // IPv6 in brackets: [::1]:1234
  if (s.startsWith('[')) {
    const end = s.indexOf(']');
    if (end > 0) return s.slice(1, end);
    return s;
  }
  // IPv4 with port: 1.2.3.4:1234
  const m = s.match(/^(\\d+\\.\\d+\\.\\d+\\.\\d+)(?::\\d+)?$/);
  if (m) return m[1];
  return s;
}

function splitXForwardedFor(xff) {
  if (!xff) return [];
  return String(xff)
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
}

function getClientIps(request) {
  const cf = request.headers.get('CF-Connecting-IP') || '';
  const xff = request.headers.get('X-Forwarded-For') || '';
  const ips = [];
  if (cf) ips.push(normalizeIp(cf));
  ips.push(...splitXForwardedFor(xff).map(normalizeIp));
  // uniq
  return {
    cf,
    xff,
    ips: Array.from(new Set(ips)).filter(Boolean),
  };
}

function isIPAllowed(ips) {
  // If allowlist is empty, allow all.
  if (!ALLOWED_IPS || ALLOWED_IPS.length === 0) return true;
  return ips.some((clientIP) => ALLOWED_IPS.some((allowed) => clientIP === allowed));
}

function getDeniedHTML(details) {
  return '<!DOCTYPE html>' +
    '<html>' +
    '<head>' +
    '  <meta charset="UTF-8">' +
    '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
    '  <meta name="robots" content="noindex,nofollow,noarchive">' +
    '  <title>Access Denied</title>' +
    '  <style>' +
    '    body {' +
    '      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;' +
    '      display: flex;' +
    '      justify-content: center;' +
    '      align-items: center;' +
    '      height: 100vh;' +
    '      margin: 0;' +
    '      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);' +
    '    }' +
    '    .container {' +
    '      text-align: center;' +
    '      background: white;' +
    '      padding: 40px;' +
    '      border-radius: 8px;' +
    '      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);' +
    '      max-width: 500px;' +
    '    }' +
    '    h1 {' +
    '      color: #d32f2f;' +
    '      margin: 0 0 16px 0;' +
    '      font-size: 28px;' +
    '    }' +
    '    p {' +
    '      color: #666;' +
    '      margin: 0;' +
    '      line-height: 1.6;' +
    '      font-size: 16px;' +
    '    }' +
    '    .error-code {' +
    '      color: #999;' +
    '      margin-top: 20px;' +
    '      font-size: 12px;' +
    '      font-family: monospace;' +
    '      background: #f5f5f5;' +
    '      padding: 10px;' +
    '      border-radius: 4px;' +
    '    }' +
    '  </style>' +
    '</head>' +
    '<body>' +
    '  <div class="container">' +
    '    <h1>â›” Access Denied</h1>' +
    '    <p>Your IP address is not authorized to access this resource.</p>' +
    '    <div class="error-code">' +
    '      CF-Connecting-IP: ' + (details.cf || '(none)') + '<br>' +
    '      X-Forwarded-For: ' + (details.xff || '(none)') + '<br>' +
    '      Parsed IPs: ' + (details.ips && details.ips.length ? details.ips.join(', ') : '(none)') +
    '    </div>' +
    '    <p style="margin-top:12px; font-size: 13px; color:#999;">Whitelist the public IP shown above (CF-Connecting-IP).</p>' +
    '  </div>' +
    '</body>' +
    '</html>';
}

export default {
  async fetch(request, env) {
    const details = getClientIps(request);
    
    if (!isIPAllowed(details.ips)) {
      return new Response(getDeniedHTML(details), {
        status: 403,
        headers: { 'Content-Type': 'text/html; charset=utf-8', 'X-Robots-Tag': ROBOTS_TAG },
      });
    }

    const url = new URL(request.url);

    const isProbablyAssetPath = (pathname) => {
      // If the path contains a dot segment (e.g. /assets/app.js, /favicon.ico), treat it as a static asset.
      // We still allow "/index.html" explicitly.
      if (!pathname) return false;
      if (pathname === '/index.html') return true;
      return pathname.split('/').some((seg) => seg.includes('.') && seg !== '.' && seg !== '..');
    };

    const wantsHtml = (req) => {
      const accept = req.headers.get('Accept') || '';
      return accept.includes('text/html');
    };

    // Cloudflare Pages provides the static asset binding as env.ASSETS.
    // For SPA routing (clean URLs), serve index.html as a fallback when a route path 404s.
    let res = await env.ASSETS.fetch(request);

    if (
      res.status === 404 &&
      request.method === 'GET' &&
      !isProbablyAssetPath(url.pathname) &&
      wantsHtml(request)
    ) {
      const indexUrl = new URL('/index.html', url);
      const indexReq = new Request(indexUrl, request);
      res = await env.ASSETS.fetch(indexReq);
    }

    const headers = new Headers(res.headers);
    headers.set('X-Robots-Tag', ROBOTS_TAG);
    return new Response(res.body, {
      status: res.status,
      statusText: res.statusText,
      headers,
    });
  },
};
`;

  fs.writeFileSync(outFile, source, 'utf8');
  console.log(`[generate-pages-worker] wrote ${path.relative(repoRoot, outFile)}`);
  if (allowedIps.length > 0) {
    console.log('[generate-pages-worker] IP allowlist enabled for oshidra.com');
  } else {
    console.log('[generate-pages-worker] IP allowlist disabled (public access)');
  }
}

main();
